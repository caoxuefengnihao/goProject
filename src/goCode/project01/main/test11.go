package main

import "fmt"

/*
go 语言不是一种传统的面向对象编程语言 它里面没有类和集成的概念
但是go语言里面有非常灵活的接口概念 通过他可以实现很多面向对象的特性
很多面向对象的语言都有相识的接口 但是go语言中的接口类型的独特之处在于它是
他是隐式实现的  也就是说我们没有必要对于给定的具体类型定义所有瞒住的接口类型 简单地拥有
一些必要的方法就足够了
这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不会改变这些类型的定义
当我们使用的类型来自于不受我们控制的包时 这种设计尤其有用
接口类型是对其他类型行为的抽象和概括 因为接口类型不会和特定的实现细节绑定在一起 通过这种抽象的方式我们可以让我们的’
函数更加灵活和更具有适应能力
接口是双方约定的一种合作协议 接口实现值者不需要关心接口会被怎样使用 调用者也不需要关心接口的实现细节
接口是一种类型也是一种抽象结构 不会暴露出所含的数据的格式 类型及结构
接口的声明格式
type 接口类型名字 interface{
	方法1（参数列表1） 返回值列表1
	方法2（参数列表2） 返回值列表2
	......
}

如果一个任意类型 T 的方法集为一个接口类型的方法集的超集，则我们说类型 T 实现了此接口类型。T 可以是一个非接口类型，也可以是一个接口类型。

实现关系在 Go语言中是隐式的。两个类型之间的实现关系不需要在代码中显式地表示出来。Go语言中没有类似于 implements 的关键字。 Go编译器将自动在需要的时候检查两个类型之间的实现关系。

接口定义后，需要实现接口，调用方才能正确编译通过并使用接口。接口的实现需要遵循两条规则才能让接口可用。
接口被实现的条件一：接口的方法与实现接口的类型方法格式一致
接口被实现的条件二：接口中所有方法均被实现

一个类型可以实现多个接口
一个接口可以被多个类型实现






*/
func main() {
	s := &Socket{}
	var w Writer
	w = s
	w.Write([]byte{1, 2, 3})
}

//类似于java中的ToString
type Stringer interface {
	String() string
}

type Socket struct {
}

func (s *Socket) Write(p []byte) (n int, err error) {
	fmt.Println("Writer", p)
	return 0, nil
}
func (s *Socket) Close() error {
	return nil
}

type Writer interface {
	Write(p []byte) (n int, err error)
}
type Closer interface {
	Close() error
}
