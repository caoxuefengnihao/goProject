package main

import "fmt"

/*
go 语言不是一种传统的面向对象编程语言 它里面没有类和集成的概念
但是go语言里面有非常灵活的接口概念 通过他可以实现很多面向对象的特性
很多面向对象的语言都有相识的接口 但是go语言中的接口类型的独特之处在于它是
他是隐式实现的  也就是说我们没有必要对于给定的具体类型定义所有瞒住的接口类型 简单地拥有
一些必要的方法就足够了
这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不会改变这些类型的定义
当我们使用的类型来自于不受我们控制的包时 这种设计尤其有用
接口类型是对其他类型行为的抽象和概括 因为接口类型不会和特定的实现细节绑定在一起 通过这种抽象的方式我们可以让我们的’
函数更加灵活和更具有适应能力
接口是双方约定的一种合作协议 接口实现值者不需要关心接口会被怎样使用 调用者也不需要关心接口的实现细节
接口是一种类型也是一种抽象结构 不会暴露出所含的数据的格式 类型及结构
接口的声明格式
type 接口类型名字 interface{
	方法1（参数列表1） 返回值列表1
	方法2（参数列表2） 返回值列表2
	......
}

如果一个任意类型 T 的方法集为一个接口类型的方法集的超集，则我们说类型 T 实现了此接口类型。T 可以是一个非接口类型，也可以是一个接口类型。

实现关系在 Go语言中是隐式的。两个类型之间的实现关系不需要在代码中显式地表示出来。Go语言中没有类似于 implements 的关键字。 Go编译器将自动在需要的时候检查两个类型之间的实现关系。

接口定义后，需要实现接口，调用方才能正确编译通过并使用接口。接口的实现需要遵循两条规则才能让接口可用。
接口被实现的条件一：接口的方法与实现接口的类型方法格式一致
接口被实现的条件二：接口中所有方法均被实现

一个类型可以实现多个接口
一个接口可以被多个类型实现
四种接口相关的类型转换情形
1:将一个非接口类型值转换为一个接口类型 在这样的转换中 此非接口值得类型必须实现了此接口类型
2:将一个接口值转换为另一个接口类型（前者接口值得类型实现了后者目标接口类型）
3:将一个接口值转换为另一个非接口类型（此非接口类型必须实现了此接口类型）
4:将一个接口值转换为另一个接口类型（前者接口值得类型可以实现了也可以未实现后者目标接口类型）

一个断言类型表达式的语法为i.(T)，其中i是一个接口值，T为一个类型字面表示 类型T可以未任意一个非接口类型 或者任意一个接口类型

一个失败的断言的估值结果为断言类型的0值 看下面示例
如果一个断言失败并且他的可选的第二个结果为呈现则此断言将造成一个恐慌

在fo语言中 接口与接口间也可以通过签到创造出新的接口

一个接口可以包含一个或多个其他的接口 这相当于直接将这些内嵌的方法列举在外层接口中一样
只要接口的所在方法被实现 则这个接口的所有嵌套接口的方法均可以被调用 代码示例如下


*/
func main() {
	s := &Socket{}
	var w Writer
	w = s
	w.Write([]byte{1, 2, 3})

	var x interface{} = 123
	n, ok := x.(int)
	fmt.Println(n, ok)
	a, ok := x.(float64)
	fmt.Println(a, ok) // 0 false
	a = x.(float64)    // 将产生一个恐慌

}

//类似于java中的ToString
type Stringer interface {
	String() string
}

type Socket struct {
}

func (s *Socket) Write(p []byte) (n int, err error) {
	fmt.Println("Writer", p)
	return 0, nil
}
func (s *Socket) Close() error {
	return nil
}

type Writer interface {
	Write(p []byte) (n int, err error)
}
type Closer interface {
	Close() error
}
